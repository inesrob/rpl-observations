<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6550.xml">
<!ENTITY RFC6775 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6775.xml">
<!ENTITY RFC6551 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6551.xml">
<!ENTITY RFC6552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6552.xml">
<!ENTITY RFC6997 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6997.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-rahul-roll-rpl-observations-01" ipr="trust200902">
    <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
      <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="RPL Observations">RPL Observations</title>

    <author fullname="Rahul Arvind Jadhav" initials="R" role="editor" surname="Jadhav">
        <organization>Huawei</organization>
        <address>
            <postal>
                <street>Kundalahalli Village, Whitefield,</street>
                <city>Bangalore</city>
                <region>Karnataka</region>
                <code>560037</code>
                <country>India</country>
            </postal>
            <phone>+91-080-49160700</phone>
            <email>rahul.ietf@gmail.com</email>
        </address>
    </author>

    <author fullname="Rabi Narayan Sahoo" initials="R.N." surname="Sahoo">
        <organization>Huawei</organization>
        <address>
            <postal>
                <street>Kundalahalli Village, Whitefield, </street>
                <city>Bangalore</city>
                <region>Karnataka</region>
                <code>560037</code>
                <country>India</country>
            </postal>
            <phone>+91-080-49160700</phone>
            <email>rabinarayans@huawei.com</email>
        </address>
    </author>

    <author fullname="Yuefeng Wu" initials="Y" surname="Wu">
        <organization>Huawei</organization>
        <address>
            <postal>
                <street>No.101, Software Avenue, Yuhuatai District,</street>
                <city>Nanjing</city>
                <region>Jiangsu</region>
                <code>210012</code>
                <country>China</country>
            </postal>
            <phone>+86-15251896569</phone>
            <email>wuyuefeng@huawei.com</email>
        </address>
    </author>

    <date year="2018" />
    <!-- Meta-data Declarations -->
    <area>Routing</area>
    <workgroup>ROLL</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
     If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>RPL, 6lo, metrics, constraints</keyword>

    <abstract>
        <t> 
            This document describes RPL protocol design issues, various
            observations and possible consequences of the design and
            implementation choices.
        </t>
    </abstract>
</front>

<middle>
    <section title="Introduction">
        <t> 
            RPL <xref target="RFC6550"/> specifies a proactive distance-vector
            routing scheme designed for LLNs (Low Power and Lossy Networks).
            RPL enables the network to be formed as a DODAG and
            supports storing mode and non-storing mode of operations.
            Non-storing mode allows reduced memory resource usage on the nodes
            by allowing non-BR nodes to operate without managing a routing
            table and involves use of source routing by the 6LBR to direct the
            traffic along a specific path. In storing mode of operation
            intermediate routers maintain routing tables.
        </t>
        <t>
            This work aims to highlight various issues with RPL which
            makes it difficult to handle certain scenarios. This work will
            highlight such issues in context to RPL's mode of operations
            (storing versus non-storing). There are cases where RPL does not
            provide clear rules and implementations have to make their choices
            hindering interoperability and performance.
        </t>
        <t>
            <xref target="I-D.clausen-lln-rpl-experiences"/> provides some
            interesting points. Some sections in this draft may overlap with
            some observations in [clausen], but this is been done to further
            extend some scenarios or observations. It is highly encouraged that
            readers should also visit <xref
                target="I-D.clausen-lln-rpl-experiences"/> for other insights.
            Regardless, this draft is self-sufficient in a way that it does not
            expect to have read [clausen-draft].
        </t>
        <!--
        <t>
            Some of the observations in the draft required experimentation.
            Experiments were conducted in Whitefield [REF] to get measurements
            and understand the impact using different open source IoT protocol
            stacks such as Contiki [REF] and RIOT [REF] which provide
            implementation of RPL.
        </t>
        -->

        <section title="Requirements Language and Terminology">
            <t>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
                NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in <xref target="RFC2119">RFC 2119</xref>.
            </t>
            <t>
                NS-MOP = RPL Non-storing Mode of Operation
            </t>
            <t>
                S-MOP = RPL Storing Mode of Operation
            </t>
            <t>
                This document uses terminology described in <xref
                    target="RFC6550"/> and <xref target="RFC6775"/>.
            </t>
        </section>
    </section>

    <section title="DTSN increment in storing MOP" anchor="DTSNincr">
        <t>
            DTSN increment has major impact on the overall RPL control traffic
            and on the efficiency of downstream route update.  DTSN is sent as
            part of DIO message and signals the downstream nodes to trigger the
            target advertisement. The 6LR needs to decide when to update the
            DTSN and usually it should do it in a conservative way. The DTSN
            update mechanism determines how soon the downward routes are
            established along the new path. RPL specifications does not provide
            any clear mechanism on how the DTSN update should happen in case of
            storing mode.
        </t>
        <t> 
            <figure align="center" anchor="sample_top" title="Sample
                topology"> <artwork align="center"><![CDATA[
     (6LBR)
        |
        |
        |
       (A)
       / \
      /   \
     /     \
   (B)    -(C)
    |    /  |
    |   /   |
    |  /    |
   (D)-    (E)
     \      ;
      \    ;
       \  ;
        (F)
        / \
       /   \
      /     \
    (G)     (H)
                    ]]></artwork> </figure> 
        </t>
        <t>
            Consider example topology shown in <xref target="sample_top"/>,
            assume that node D switches the parent from node B to C. Ideally
            the downstream nodes D and its sub-childs should send their target
            advertisement to the new path via node C.  To achieve this result
            in a efficient way is a challenge.  Incrementing DTSN is the only
            way to trigger the DAO on downstream nodes. But this trigger should
            be sent not only on the first hop but to all the grand-child nodes.
            Thus DTSN has to be incremented in the complete sub-DODAG rooted at
            node D thus resulting in DIO/DAO storm along the sub-DODAG. This is
            specifically a big issue in high density networks where the metric
            deteoration might happen transiently even though the signal
            strength is good.
        </t>
        <t>
            The primary implementation issue is whether a child node increment
            its own DTSN when it receives DTSN update from its parent node?
            This would result in DAO-updates in the sub-DODAG, thus the cost
            could be very high. If not incremented it may result in serious
            loss of connectivity for nodes in the sub-DODAG.
        </t>
        <section title="Deliberations">
            <t>
                <list style="format (%d)">
                    <t> 
                        In S-MOP, should the child nodes increment its DIO on
                        seeing that its preferred parent has updated its DTSN?
                    </t>
                    <t> 
                        What are rules for DTSN increment for storing MOP,
                        which multiple implementations can follow thus allowing
                        consistent performance across different
                        implementations?
                    </t>
                </list>
            </t>
        </section>
    </section>

    <section title="DAO retransmission and use of DAO-ACK in storing MOP">
        <t>
            <xref target="RFC6550"/> has an optional DAO-ACK mechanism using
            which an upstream parent confirms the reception of a DAO from the
            downstream child. In case of storing mode, the DAO is addressed to
            the immediate hop upstream parent resulting in DAO-ACK from the
            parent. There are two implementations possible:
            <list style="format (%d)">
                <t>
                    Hop-by-hop ACK: A parent responds with a DAO-ACK
                    immedetialy after receiving the DAO.
                </t>
                <t>
                    End-to-End ACK: A node waits for the upstream parent to
                    send DAO-ACK to respond with a DAO-ACK downstream. The
                    upstream parent may do as many attempts to successfully
                    send this DAO upstream. In other words, the parent node
                    accepts the responsibilty of sending the DAO upstream till
                    the point it is ACKed the moment it responds back with its
                    own ACK to the child.
                </t>
            </list>
        </t>
        <t>
            <figure align="center" anchor="hbh_ack" title="Hop-by-hop DAO-ACK">
                <artwork align="center"><![CDATA[
           1->          3->
           DAO          DAO
(TgtNode)--------(6LR)-------(root)
           ACK          ACK
           <-2          <-4
                    ]]></artwork> </figure> 
        </t>
        <t>
            <figure align="center" anchor="e2e_ack" title="End-to-End DAO-ACK">
                <artwork align="center"><![CDATA[
           1->          2->
           DAO          DAO
(TgtNode)--------(6LR)-------(root)
           ACK          ACK
           <-4          <-3
                    ]]></artwork> </figure> 
        </t>
        <section title="Significance of bidirectional Path establishment
            indication and relevance of DAO-ACK">
            <t>
                Lot of application traffic patterns requires that the
                bidirectional path be established between the target node and
                the root. A typical example is that COAP request with ACK bit
                set would require an acknowledgement from the end receiver and
                thus warrants bidirectional path establishment. It is
                imperative that the target node first ascertains whether such a
                bidirectional path is established before initiating such
                application traffic. In case of non-storing MOP, the DAO-ACK
                works perfectly fine to ascertain such bidirectional
                connectivity since it is an indication that the root which
                usually is the direct destination of the DAO has received the
                DAO. But in case of storing MOP, things are more complicated
                since DAO is sent hop-by-hop and the DAO-ACK semantics are not
                clear enough as per the current specification. As mentioned in
                above section, an implementation can choose to implement
                hop-by-hop ACK or end-to-end ACK.
            </t>
        </section>
        <section title="Problems with hop-by-hop DAO-ACK">
            <t>
                The primary issue with this mode is that target node cannot
                ascertain bidirection path connectivity on the reception of the
                DAO-ACK.
            </t>
        </section>
        <section title="Problems with end-to-end DAO-ACK">
            <t>
                In this case, it is possible for the target node to ascertain
                if the DAO has indeed reached the root since the reception of
                DAO-ACK on target node confirms this. However there is extra
                state information that needs to be maintained on the 6LRs on
                behalf of all the child nodes. Also it is very difficult for
                the target node to ascertain a timer value to decide whether
                the DAO transmission has failed to reach the root.
            </t>
        </section>
        <section title="Deliberations">
            <t>
                <list style="format (%d)">
                    <t>
                        How should an implementation interpret the DAO-ACK
                        semantics?
                    </t>
                    <t> 
                        What is the best way for the target node to know that
                        the end to end bidirectional path is successfully
                        installed or updated? In NS-MOP, the DAO-ACK provides a
                        clear way to do this. Can the same be achieved for
                        storing-MOP?
                    </t>
                    <t>
                        What happens if the DAO-ACK with Status!=0 is responded by
                        ancestor node?
                    </t>
                    <t>
                        How to selectively NACK subset of targets in case
                        target containers are aggregated?
                    </t>
                </list>
            </t>
        </section>
        <section title="Implementation Notes">
            <t>
                Current RPL open source implementations have both types of
                DAO-ACK implementations. For e.g. RIOT supports hop-by-hop
                DAO-ACK. Contiki older versions supported hop-by-hop ACK but
                the recent version have changed to end-to-end ACK
                implementation.
            </t>
            <t>
                The sequence of sending no-path DAO and DAO matters when
                updating the routing adjacencies on a parent switch. If an
                implementation chooses to send no-path DAO before DAO then it
                results in significantly more overhead for route invalidation.
                This is because no-path DAO would traverse all the way up to
                the BR clearing the routes on the way. In case there is a
                common ancestor post which the old and new path remains same
                then it is better to send regular DAO first thus limiting the
                propagation of subsequent no-path DAO till this common
                ancestor.
            </t>
        </section>
    </section>

    <section title="Handling resource unavailability">
        <t>
            The nodes in the constrained networks have to maintain various
            records such as neighbor cache entries and routing entries on
            behalf of other targets to facilitate packet forwarding. Because of
            the constrained nature of the devices the memory available may be
            very limited and thus the path selection algorithm may have to take
            into consideration such resource constraints as well.
        </t>
        <t>
            RPL currently does not have any mechanism to advertise such
            resource indicator metrics. The primary tables associated with RPL
            are routing table and the neighbor cache. Even though neighbor
            cache is not directly linked with RPL protocol, the maintenance of
            routing adjacencies results in updates to neigbor cache.
        </t>
        <section title="Deliberations">
            <t>
                <list>
                    <t>
                        Is it possible to know that an upstream parent/ancestor
                        cannot hold enough routing entries and thus this path
                        should not be used?
                    </t>
                    <t>
                        Is it possible to know that an upstream parent cannot
                        hold any more neighbor cache entry and thus this
                        upstream parent should not be used?
                    </t>
                </list>
            </t>
        </section>
    </section>

    <!--
    TODO: Not sure if this section helps the purpose! Not adding it now even
    though i have the data.
    <section title="RPL Control traffic observations">
            <t>
                Breakup of DIS, DIO, DAO traffic for RIOT, Contiki for the given networks.
                Convergence times.
                Difference in control traffic for RIOT and contiki
            </t>
    </section>
    -->

    <section title="Handling aggregated targets">
        <t>
            RPL allows and defines specific procedures so as to aid target
            aggregation in DAO. Having said that, the specification does not
            mandate use of aggregated targets nor does it make any comment on
            whether a receiving node needs to handle it. Target aggregation is
            an useful tool and especially helps with link layer technologies
            that does not suffer from low MTUs such as PLC. Even if the
            implementation does not support aggregating targets, it should
            atleast mandate reception of aggregated targets in DAO. 
        </t>
        <t>
            RPL has a mechanism currently to ACK the DAO but it does not have a
            mechanism to ACK the target container. Thus in case of aggregated
            targets in the DAO, if the subset of the targets fail then it is
            impossible for the DAO-ACK to signal this to the DAO sender.
        </t>
        <section title="Deliberations">
            <t>
                <list>
                    <t>
                        Even if the implementation does not support aggregating
                        targets, should it atleast mandate reception and
                        handling of aggregated targets in DAO?
                    </t>
                    <t>
                        There is a good scope for compressing aggregated
                        targets which can significantly reduce the RPL control
                        overhead.
                    </t>
                    <t>
                        How to selectively NACK subset of targets in case
                        target containers are aggregated?
                    </t>
                    <t>
                        The DEFAULT_DAO_DELAY of 1sec does not help much with
                        aggregation. The upstream parent nodes should wait for
                        more time then the child nodes so as to effectively
                        aggregate. Can we have DEFAULT_DAO_DELAY a function of
                        the level/rank the node is at?
                    </t>
                </list>
            </t>
        </section>
    </section>

    <!--
    <section title="Network density and DIO Trickle Timer">
        <t>
            DIORedundancy with high node density.
        </t>
    </section>

    <section title="Operating in router mode">
        <t>
            RPL allows a node to be either in a 6LBR, 6LR or 6LN. Nodes are
            provisioned to operate in 6LR mode. This decision should be
            dynamic. RPL does not provide any mechanism for detection and
            converting to 6LR mode.
        </t>
    </section>
    -->

    <section title="RPL Transit Information in DAO">
        <t>
            RPL allows associating a target or set of targets with a Transit
            information container which contains attributes for a path to one
            or more destinations identified by the set of targets. In case of
            NS-MOP, the transit Information will contain the all critical
            Parent Address which allows the common ancestor usually the root to
            identify the source route header for the target node. The Transit
            Information also contains other information such as Path Sequence
            and Path Lifetime which are critical for maintaining route
            adjacencies.
        </t>
        <t>
            RPL however does not mandate the use of Transit Information
            container for targets.
        </t>
        <section title="Deliberations">
            <t>
                <list>
                    <t>
                        Is it ok to let implementations decide on the inclusion
                        of Transit Information container?
                    </t>
                    <t>
                        Is it possible to achieve interop without mandating use
                        of Transit Information Container?
                    </t>
                    <t>
                        If the Transit Information container is sent, should
                        the handling of PathSequence be mandated?
                    </t>
                    <t>
                        The DEFAULT_DAO_DELAY of 1sec does not help much with
                        aggregation. The upstream parent nodes should wait for
                        more time then the child nodes so as to effectively
                        aggregate. Can we have DEFAULT_DAO_DELAY a function of
                        the level/rank the node is at?
                    </t>
                </list>
            </t>
        </section>
    </section>

    <section title="Managing persistent variables across node reboots">
        <section title="Persistent storage and RPL state information">
            <t>
                Devices are required to be functional for several years without
                manual maintanence. Usually battery power consumption is
                considered key for operating the devices for several (tens of)
                years. But apart from battery, flash memory endurance may prove
                to be a lifetime bottleneck in constrained networks.  Endurance
                is defined as maximum number of erase-write cycles that a
                NAND/NOR cell can undergo before losing its 'gauranteed' write
                operation. In some cases (cheaper NAND-MLC/TLC), the endurance
                can be as less as 2K cycles. Thus for e.g.  if a given cell is
                written 5 times a day, that NAND-flash cell assuming an
                endurance of 10K cycles may last for less than 6 years.
            </t>
            <t>
                Wear leveling is a popular technique used in flash memory to
                minimize the impact of limited cell endurance. Wear leveling
                works by arranging data so that erasures and re-writes are
                distributed evenly across the medium. The memory sectors are
                over-provisioned so that the writes are distributed across
                multiple sectors. Many IoT platforms do not necessarily
                consider this over-provisioning and usually provision the
                memory only to what is required. Some scenarios such as
                street-lighting may not require the application layer to write
                any information to the persistent storage and thus the
                over-provisioning is often ignored. In such cases if the
                network stack ends up using persistent storage for maintaining
                its state information then it becomes counter-productive.
            </t>
            <t>
                In a star topology, the amount of persistent data write done by
                network protocols is very limited. But ad-hoc networks
                employing routing protocols such as RPL assume certain state
                information to be retained across node reboots. In case of IoT
                devices this storage is mostly floating gate based NAND/NOR
                based flash memory. The impact of loss of this state
                information differs depending upon the type (6LN/6LR/6LBR) of
                the node.
            </t>
        </section>
        <section title="Lollipop Counters">
            <t>
                <xref target="RFC6550"/> Section 7.2. explains sequence counter
                operation defining lollipop <xref target="Perlman83"/> style
                counters. Lollipop counters specify mechanism in which even if
                the counter value wraps, the algorithm would be able to tell
                whether the received value is the latest or not. This mechanism
                also helps in "some cases" to recover from node reboot, but is
                not foolproof.
            </t>
            <t>
                Consider an e.g. where Node A boots up and initialises the
                seqcnt to 240 as recommended in <xref target="RFC6550"/>. Node
                A communicates to Node B using this seqcnt and node B uses this
                seqcnt to determine whether the information node A sent in the
                packet is latest. Now lets assume, the counter value reaches
                250 after some operations on Node A, and node B keeps receiving
                updated seqcnt from node A. Now consider that node A reboots,
                and since it reinitializes the seqcnt value to 240 and sends
                the information to node B (who has seqcnt of 250 stored on
                behalf of node A). As per section 7.2. of <xref
                    target="RFC6550"/>, when node B receives this packet it
                will consider the information to be old (since 240 &lt; 250).
            </t>
            <texttable anchor="lollipop" title="Example lollipop counter operation">
                <ttcol align='center'>A</ttcol>
                <ttcol align='center'>B</ttcol>
                <ttcol align='center'>Output</ttcol>
                <c>240</c>  <c>240</c>   <c>A&lt;B, old</c>
                <c>240</c>  <c>241</c>   <c>A&lt;B, old</c>
                <c>240</c>  <c>::</c>    <c>A&lt;B, old</c>
                <c>240</c>  <c>256</c>   <c>A&lt;B, old</c>
                <c>240</c>  <c>0</c>     <c>A&lt;B, new</c>
                <c>240</c>  <c>1</c>     <c>A&gt;B, new</c>
                <c>240</c>  <c>::</c>    <c>A&gt;B, new</c>
                <c>240</c>  <c>127</c>   <c>A&gt;B, new</c>
                <postamble>Default values for lollipop counters considered from
                    <xref target="RFC6550"/> Section 7.2.</postamble>
            </texttable>
            <t>
                Based on this figure, there is dead zone (240 to 0) in which if
                A operates after reboot then the seqcnt will always be
                considered smaller.  Thus node A needs to maintain the seqcnt
                in persistent storage and reuse this on reboot.
            </t>
        </section>
        <section title="RPL State variables">
            <t>
                The impact of loss of RPL state information differs depending
                upon the node type (6LN/6LR/6LBR). Following sections explain
                different state variables and the impact in case this
                information is lost on reboot.
            </t>
            <section title="DODAG Version">
                <t>
                    The tuple (RPLInstanceID, DODAGID, DODAGVersionNumber)
                    uniquely identifies a DODAG Version.  DODAGVersionNumber is
                    incremented everytime a global repair is initiated for the
                    instance (global or local). A node receiving an older
                    DODAGVersionNumber will ignore the DIO message assuming it
                    to be from old DODAG version. Thus a 6LBR node (and 6LR
                    node in case of local DODAG) needs to maintain the
                    DODAGVersionNumber in the persistent storage, so as to be
                    available on reboot.  In case the 6LBR could not use the
                    latest DODAGVersionNumber the implication are that it won't
                    be able to recover/re-establish the routing table.
                </t>
            </section>
            <section title="DTSN field in DIO">
                <t>
                    DTSN (Destination advertisement Trigger Sequence Number) is
                    a DIO message field used as part of procedure to maintain
                    Downward routes. A 6LBR/6LR node may increment a DTSN in
                    case it requires the downstream nodes to send DAO and thus
                    update downward routes on the 6LBR/6LR node. In case of RPL
                    NS-MOP, only the 6LBR maintains the downward routes and
                    thus controls this field update. In case of S-MOP, 6LRs
                    additionally keep downward routes and thus control this
                    field update.
                </t>
                <t>
                    In S-MOP, when a 6LR node switches parent it may have to
                    issue a DIO with incremented DTSN to trigger downstream
                    child nodes to send DAO so that the downward routes are
                    established in all parent/ancestor set. Thus in S-MOP, the
                    frequency of DTSN update might be relatively high (given
                    the node density and hysteresis set by objective function to
                    switch parent).
                </t>
            </section>
            <section title="PathSequence">
                <t>
                    PathSequence is part of RPL Transit Option, and associated
                    with RPL Target option. A node whichs owns a target address
                    can associate a PathSequence in the DAO message to denote
                    freshness of the target information. This is especially
                    useful when a node uses multiple paths or multiple parents
                    to advertise its reachability.
                </t>
                <t>
                    Loss of PathSequence information maintained on the target
                    node can result in routing adjacencies been lost on
                    6LRs/6LBR/6BBR.
                </t>
            </section>
        </section>
        <section title="State variables update frequency">
            <!--
                TODO: Show contiki data as in how many number of times does the
                DTSN, DAOSequence change?  REF for TI-CC2538
                [http://www.ti.com/lit/ug/swru319c/swru319c.pdf]
                [http://www.ti.com/lit/wp/spry164/spry164.pdf] CC2538 which
                uses MLC-NAND for flash storage has 3000-5000 endurance rating.
            -->
            <texttable anchor="rpl_state" title="RPL State variables">
                <ttcol align='center'>State variable</ttcol>
                <ttcol align='center'>Update frequency</ttcol>
                <ttcol align='center'>Impacts node type</ttcol>
                <c>DODAGVersionNumber</c> <c>Low</c>               <c>6LBR, 6LR(local DODAG)</c>
                <c>DTSN</c>               <c>High(SM),Low(NSM)</c> <c>6LBR, 6LR</c>
                <c>PathSequence</c>       <c>High(SM),Low(NSM)</c> <c>6LR, 6LN</c>
                <postamble>Low=&lt;5 per day, High=&gt;5 per day; SM=Storing MOP, NSM=Non-Storing MOP</postamble>
            </texttable>
        </section>
        <section title="Deliberations">
            <t>
                <list style="format (%d)">
                    <t> 
                        Is it possible that RPL reduces the use of persistent
                        storage for maintaining state information?
                    </t>
                    <t> 
                        In most cases, the node reboots will happen very rarely. Thus
                        doing a persistent storage book-keeping for handling node
                        reboot might not make sense. Is it possible to consider
                        signaling (especially after the node reboots) so as to avoid
                        maintaining this persistent state?  Is it possible to use
                        one-time on-reboot signalling to recover some state
                        information?
                    </t>
                    <t>
                        It is necessary that RPL avoids using persistent
                        storage as far as possible. Ideally, extensions to RPL
                        should consider this as a design requirement especially
                        for 6LR and 6LN nodes. DTSN and PathSequence are the
                        primary state variables which have major impact.
                    </t>
                </list>
            </t>
        </section>
        <section title="Implementation Notes">
            <t>
                An implementation should use a random DAOSequence number on
                reboot so as to avoid a risk of reusing the same DAOSequence on
                reboot. Regardless the sequence counter size of 8bits does not
                provide much gurantees towards choosing a good random number. A
                parent node will not respond with a DAO-ACK in case it sees a
                DAO with the same previous DAOSequence.
            </t>
            <t>
                Write-Before-Use: The state information should be written
                to the flash before using it in the messaging. If it is
                done the other way, then the chances are that the node
                power downs before writing to the persistent storage.
            </t>
        </section>
    </section>

    <section title="RPL under-specification">
        <t>
            <list style="format (%c)">
                <t>
                    PathSequence: Is it mandatory to use PathSequence in DAO
                    Transit container? RPL mentions that a 6LR/6LBR hosting the
                    routing entry on behalf of target node should refresh the
                    lifetime on reception of a new Path Sequence. But RPL does
                    not necessarily mandate use of Path Sequence. Most of the
                    open source implementation [RIOT] [CONTIKI] currently do
                    not issue Path Sequence in the DAO message.
                </t>
                <t>
                    Target Container aggregation in DAO: RPL allows multiple
                    targets to be aggregated in a single DAO message and has
                    introduced a notion of DelayDAO using which a 6LR node
                    could delay its DAO to enable such aggregation. But RPL
                    does not have clear text on handling of aggregated DAOs and
                    thus it hinders interoperability.
                </t>
                <t>
                    DTSN Update: RPL does not clearly define in which cases
                    DTSN should be updated in case of storing mode of
                    operation. More details for this are presented in <xref
                        target="DTSNincr"/>.
                </t>
            </list>
        </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
        <t>
            Many thanks to Pascal Thubert for hallway chats and for helping
            understand the existing design rationales. Thanks to Michael
            Richardson for Unstrung RPL implementation rationale. Thanks to ML
            discussions, in particular
            (https://www.ietf.org/mail-archive/web/roll/current/msg09443.html).
        </t>
    </section>

<!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
        <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
        <t>
            This is an information draft and does add any changes to the
            existing specifications.
        </t>
    </section>
</middle>

<back>
    <!-- References split into informative and normative -->
    <references title="Normative References">
        <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
        &RFC2119;
        &RFC6550;
        &RFC6551;
        &RFC6552;
        &RFC6775;
        &RFC6997;

    </references>

    <references title="Informative References">
        <reference anchor="Perlman83">
            <front>
                <title>Fault-Tolerant Broadcast of Routing Information</title>
                <author initials="R" surname="Perlman">
                    <organization></organization>
                </author>
                <date year="December 1983" />
            </front>
            <seriesInfo name="North-Holland Computer Networks," value="Vol.7"/>
        </reference>

        <!-- Here we use entities that we defined at the beginning. -->
        <?rfc include="reference.I-D.clausen-lln-rpl-experiences.xml"?>
    </references>

    <section anchor="app-additional" title="Additional Stuff">
    </section>

</back>
</rfc>
